[tasks.default]
alias = "help"

[tasks.help]
category = "Help"
description = "Display available tasks"
script = [
  "cargo make --silent --list-all-steps --hide-uninteresting",
  "echo",
  "echo 'Examples:'",
  "echo '  cargo make build'",
  "echo '  cargo make wasm'",
  "echo '  cargo make test'",
  "echo '  cargo make format'",
  "echo '  cargo make lint'",
  "echo",
  "echo 'Deployment (cw-orchestrator):'",
  "echo '  cargo make deploy-contract axone-gov local          # Deploy to local network'",
  "echo '  cargo make deploy-contract axone-gov testnet        # Deploy to Axone testnet'",
  "echo '  cargo make deploy-contract axone-gov local testnet  # Deploy to multiple networks'",
  "echo",
  "echo 'Supported networks: local, testnet, mainnet, axone-localnet, axone-dentrite-1, axone-1'",
  "echo 'Also supports other cw-orch networks: uni-6, osmo-test-5, juno-1, etc.'",
]

[tasks.format-rust]
category = "Code Quality"
dependencies = ["install-cargo-sort-derives"]
description = "Format rust sources files. (rustfmt provided by rust-toolchain.toml)"
script = ["cargo fmt", "cargo sort-derives"]

[tasks.lint-rust-format]
category = "Code Quality"
dependencies = ["install-cargo-sort-derives"]
description = "Check formatting and derives order (rustfmt via rust-toolchain.toml)."
script = ["cargo fmt --all -- --check", "cargo sort-derives --check"]

[tasks.lint-rust-clippy]
args = ["cranky"]
category = "Code Quality"
command = "cargo"
dependencies = ["install-cranky"]
description = "Check lint of all sources files (clippy via rust-toolchain.toml)."

[tasks.lint-rust]
category = "Code Quality"
dependencies = ["lint-rust-format", "lint-rust-clippy"]
description = "Check all Rust linting (formatting and clippy)."

[tasks.lint-toml]
args = ["lint"]
category = "Code Quality"
command = "taplo"
dependencies = ["install-taplo-cli"]
description = "Check lint of all toml files."

[tasks.lint-cargo-toml-file]
category = "Code Quality"
dependencies = ["install-cargo-toml-lint"]
description = "Check lint of the given toml file"
script = '''
cargo-toml-lint "${@}"
'''

[tasks.lint-cargo-toml]
category = "Code Quality"
description = "Check lint of all Cargo.toml files."
script = '''
find . -type f \( -name "Cargo.toml" \) -print0 | xargs -0 -n1 cargo make lint-cargo-toml-file
'''

[tasks.lint-cargo-deps]
args = ["machete", "--with-metadata"]
category = "Code Quality"
command = "cargo"
dependencies = ["install-cargo-machete"]
description = "Check for unused dependencies."

[tasks.lint-cargo]
category = "Code Quality"
dependencies = ["lint-cargo-toml", "lint-cargo-deps"]
description = "Check all Cargo linting (toml files and dependencies)."

[tasks.format-toml]
args = ["fmt"]
category = "Code Quality"
command = "taplo"
dependencies = ["install-taplo-cli"]
description = "Format toml file"

[tasks.lint]
category = "Code Quality"
dependencies = ["lint-rust", "lint-cargo", "lint-toml"]
description = "Check all linting (Rust, Cargo, and TOML)."

[tasks.format]
category = "Code Quality"
dependencies = ["format-rust", "format-toml"]
description = "Format all files (Rust and TOML)."

[tasks.clean-cargo]
args = ["clean"]
category = "Cleanup"
command = "cargo"
description = "Clean cargo build artifacts."

[tasks.clean]
category = "Cleanup"
dependencies = ["clean-cargo", "clean-docs", "clean-chain"]
description = "Clean all artifacts (cargo, docs, and chain)."

[tasks.build]
args = ["build", "--release", "--locked"]
category = "Build"
command = "cargo"

[tasks.test-unit]
args = ["test", "--lib", "--tests", "--workspace", "--locked"]
category = "Testing"
command = "cargo"
description = "Run all unit tests."

[tasks.test-coverage]
args = ["llvm-cov", "--workspace", "--lcov", "--output-path", "lcov.info"]
category = "Testing"
command = "cargo"
dependencies = ["install-llvm-cov"]
description = "Run tests with coverage reporting."

[tasks.test]
category = "Testing"
dependencies = ["test-unit"]
description = "Run all tests."

[tasks.wasm]
args = [
  "hack",
  "build",
  "--release",
  "--lib",
  "--target",
  "wasm32-unknown-unknown",
  "--locked",
  "--workspace",
  "--exclude",
  "axone-scripts",
]
category = "Build"
command = "cargo"
dependencies = ["install-cargo-hack"]

[tasks.schema]
category = "Build"
description = "Generate JSON schemas for all contracts."
script = '''
echo "üìã Generating schemas for all contracts..."
for contract_dir in contracts/*/; do
    if [ -d "$contract_dir" ]; then
        contract_name=$(basename "$contract_dir")
        echo "üîß Generating schema for $contract_name..."
        (cd "$contract_dir" && cargo make schema)
    fi
done
echo "‚úÖ All schemas generated"
'''

[tasks.check-contracts]
category = "Verification"
dependencies = ["install-cosmwasm-check", "wasm"]
description = "Check WASM contracts validity."
script = '''
cosmwasm-check ${DIR_WASM}/*.wasm
'''

[tasks.clean-docs]
category = "Cleanup"
description = "Clean documentation folder."
script = '''
echo "üßπ Cleaning documentation folder"
rm -rf ${DOCS_FOLDER}/*
'''

[tasks.check-npx]
category = "Verification"
description = "Check npx is installed"
script = '''
if ! command -v npx >/dev/null 2>&1; then
   echo "‚ùå npx could not be found"
   echo "   Consider installing npx with: npm install -g npx"
   exit 1
fi
'''

[tasks.check-awk]
category = "Verification"
description = "Check awk is installed"
script = '''
if ! command -v awk >/dev/null 2>&1; then
   echo "‚ùå awk could not be found"
   echo "   Consider installing awk (usually pre-installed on Unix systems)"
   exit 1
fi
'''

[tasks.check-perl]
category = "Verification"
description = "Check perl is installed"
script = '''
if ! command -v perl >/dev/null 2>&1; then
   echo "‚ùå perl could not be found"
   echo "   Consider installing perl (usually pre-installed on Unix systems)"
   exit 1
fi
'''

[tasks.check-jq]
category = "Verification"
description = "Check jq is installed (version 1.7 or higher, but below 2.0)"
script = '''
if ! command -v jq >/dev/null 2>&1; then
   echo "‚ùå jq could not be found"
   echo "   Consider installing jq: brew install jq (macOS) or apt-get install jq (Linux)"
   exit 1
fi

jq_version=$(jq --version 2>/dev/null | sed -E 's/^jq-([0-9]+)\.([0-9]+).*/\1.\2/')
if ! printf '%s' "$jq_version" | grep -Eq '^[0-9]+\.[0-9]+$'; then
  echo "‚ùå Could not determine jq version (got: '$jq_version')"
  exit 1
fi
jq_major=${jq_version%%.*}
jq_minor=${jq_version#*.}

if [ "$jq_major" -lt 1 ] || ([ "$jq_major" -eq 1 ] && [ "$jq_minor" -lt 7 ]); then
  echo "‚ùå jq version $jq_version is too old (require >= 1.7)"
  exit 1
fi

if [ "$jq_major" -ge 2 ]; then
  echo "‚ö†Ô∏è  Warning: jq version $jq_version is untested (expected >= 1.7 and < 2.0)"
fi
'''

[tasks.check-prerequisites]
category = "Verification"
dependencies = ["check-npx", "check-awk", "check-perl", "check-jq"]
description = "Check all the prerequisites are installed."
script = '''
echo "‚úÖ All prerequisites are satisfied"
'''

[tasks.check]
category = "Verification"
dependencies = ["check-prerequisites", "check-contracts"]
description = "Check all requirements (prerequisites and contracts)."

[tasks.docs]
category = "Documentation"
dependencies = ["check-prerequisites", "clean-docs", "schema"]
description = "Generate documentation"
script = '''
echo "üßπ Cleaning old documentation..."
rm -rf $SCHEMA_FOLDER
rm -rf $DOCS_FOLDER

echo "üìö Generating documentation in ${DOCS_FOLDER} folder..."

mkdir -p "$SCHEMA_FOLDER"
find contracts -mindepth 2 -maxdepth 3 -path "*/schema/module-schema.json" -print0 \
  | while IFS= read -r -d '' schema; do
      contract=$(basename "$(dirname "$(dirname "$schema")")")
      dest="${SCHEMA_FOLDER}/${contract}.json"
      cp "$schema" "$dest"
      jq "
        def ensure_one_of:
          if . == null then .
          elif has(\"oneOf\") then .
          else
            {
              title: (.title // \"\"),
              description: (.description // \"\"),
              oneOf: [
                {
                  title: (.title // \"\"),
                  description: (.description // \"\"),
                  type: (.type // \"object\"),
                  required: (.required // []),
                  properties: (.properties // {}),
                  additionalProperties: (.additionalProperties // false)
                }
              ]
            }
          end;
        def annotate_variants:
          if . == null or (type != \"object\") then .
          elif has(\"oneOf\") then
            .oneOf = [
              .oneOf[]
              | if (has(\"title\") and (.title | length > 0)) then .
                elif (has(\"properties\") and (.properties | type == \"object\") and ((.properties | keys) | length) == 1) then
                  . + { title: (.properties | keys | first) }
                else .
                end
            ]
          else .
          end;
        (.instantiate |= (ensure_one_of | annotate_variants))
        | (.execute |= annotate_variants)
        | (.query |= annotate_variants)
        | (.migrate |= (ensure_one_of | annotate_variants))
      " "$dest" > "${dest}.tmp" && mv "${dest}.tmp" "$dest"
    done

mkdir -p "$DOCS_FOLDER"

set -- "$SCHEMA_FOLDER"/*.json
if [ "$1" = "$SCHEMA_FOLDER/*.json" ]; then
    echo "‚ö†Ô∏è  No schema files to render"
else
    for SCHEMA_FILE in "$@"; do
        from=$(basename "$SCHEMA_FILE")
        to="${from%.json}.md"
        echo "‚úçÔ∏è Rendering ${SCHEMA_FOLDER}/$from to $to"

        awk "{sub(\"#/definitions\",\"./${from}/#/definitions\")} {print}" "${SCHEMA_FOLDER}/${from}" > "${SCHEMA_FOLDER}/${from}.tmp"
        mv "${SCHEMA_FOLDER}/${from}.tmp" "${SCHEMA_FOLDER}/${from}"

        npx --yes @fadroma/schema@1.1.0 "${SCHEMA_FOLDER}/${from}" > "docs/${to}.tmp"

        perl << 'EOF' - "docs/${to}.tmp" > "docs/${to}"
        use strict;
        use warnings;
        use autodie;

        my $file = shift @ARGV;
        local $/ = undef;

        open my $fh, '<', $file or die "‚ò†Ô∏è Could not open file: $!";
        my $content = <$fh>;
        close $fh;

        my $in_code_block = 0;
        my $in_inline_code = 0;
        my $escaped_content = '';
        my @chars = split //, $content;

        for (my $i = 0; $i < @chars; $i++) {
            my $char = $chars[$i];
            my $emitted = '';

            if ($char eq '`') {
                my $next_char = $chars[$i + 1] // '';
                my $next_next_char = $chars[$i + 2] // '';
                if ($next_char eq '`' && $next_next_char eq '`') {
                    $in_code_block = !$in_code_block;
                    $i += 2;
                    $emitted = '```';
                } elsif (!$in_code_block) {
                    $in_inline_code = !$in_inline_code;
                    $emitted = '`';
                } else {
                    $emitted = $char;
                }
            } elsif ($char eq '\n') {
              $in_inline_code = 0;
              $emitted = $char;
            } elsif (!$in_code_block && !$in_inline_code && ($char eq '{' || $char eq '}')) {
                $emitted = "\\$char";
            } else {
                $emitted = $char;
            }

            $escaped_content .= $emitted;
        }

        print $escaped_content;
EOF

        rm "docs/${to}.tmp"
    done
fi

rm -rf $SCHEMA_FOLDER

echo "üìê Formatting documentation..."
npx --yes prettier@3.1.1 docs/*.md --write

echo "üìñ Documentation has been successfully generated and available at $(pwd)/$DOCS_FOLDER/README.md"
'''
script_runner = "bash"

[tasks.release-wasm]
category = "Build"
description = "Build optimized wasm using CosmWasm optimizer and provide checksums"
script = '''
echo "üì¶ Generating release binaries and checksums into ${DIR_WASM}"
docker run --rm -v "$(pwd)":/code \
  --mount type=volume,source="$(basename "$(pwd)")_cache",target=/target \
  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \
  ${DOCKER_IMAGE_COSMWASM_OPTIMIZER}
'''

[tasks.deploy-script]
category = "Deployment"
description = "Run a contract deployment script. Usage: cargo make deploy-script <script> <package> <network-ids...>"
script = '''
if [ -z "$1" ]
then
  echo "‚ùå Please provide the script name as the first argument (e.g., publish)"
  exit 1
fi
script=$1

if [ -z "$2" ]
then
  echo "‚ùå Please provide the package name as the second argument (e.g., axone-gov)"
  exit 1
fi
package=$2

shift 2
networks="$@"

if [ -z "$networks" ]
then
  echo "‚ùå Please provide at least one network id (e.g., local, testnet, mainnet)"
  exit 1
fi

echo "üöÄ Running script '${script}' for package '${package}' on networks: ${networks}"
ARTIFACTS_DIR="${DIR_WASM}" cargo run --bin ${script} --package ${package} --features="daemon-bin" -- --network-ids ${networks}
'''

[tasks.deploy-contract]
category = "Deployment"
description = "Publish a contract to Abstract on specified networks. Usage: cargo make deploy-contract <contract-name> <network-ids...>"
script = '''
if [ -z "$1" ]
then
  echo "‚ùå Please provide the contract name as the first argument (e.g., axone-gov)"
  exit 1
fi
contract=$1

shift
networks="$@"

if [ -z "$networks" ]
then
  echo "‚ùå Please provide at least one network id (e.g., local, testnet, mainnet)"
  exit 1
fi

# Check if artifacts directory exists, if not build WASM
if [ -d "${DIR_WASM}" ] && [ "$(ls -A ${DIR_WASM}/*.wasm 2>/dev/null)" ]; then
  echo "‚úÖ Build found in ${DIR_WASM}"
else
  echo "üì¶ Building WASM contracts..."
  cargo make wasm
fi

# Ensure cw-orch can locate the built wasm files
mkdir -p artifacts
cp -f ${DIR_WASM}/*.wasm artifacts/

echo "üì§ Publishing ${contract} to networks: ${networks}"
cargo make deploy-script publish ${contract} ${networks}
'''

[tasks.deploy-abstract]
category = "Deployment"
dependencies = ["chain-start"]
description = "Deploy Abstract infrastructure to specified networks. Usage: cargo make deploy-abstract <network-ids...>"
script = '''
if [ -z "$1" ]
then
  echo "‚ùå Please provide at least one network id (e.g., local, testnet, mainnet)"
  exit 1
fi

networks="$@"

echo "üöÄ Deploying Abstract infrastructure to networks: ${networks}"
cargo run --bin deploy_abstract --package axone-scripts -- --network-ids ${networks}
'''

[tasks.deploy-install]
category = "Deployment"
description = "Install a module on an Abstract Account. Usage: cargo make deploy-install <contract-name> <network-ids...>"
script = '''
if [ -z "$1" ]
then
  echo "‚ùå Please provide the contract name as the first argument (e.g., axone-gov)"
  exit 1
fi
contract=$1

shift
networks="$@"

if [ -z "$networks" ]
then
  echo "‚ùå Please provide at least one network id (e.g., local, testnet, mainnet)"
  exit 1
fi

echo "üì• Installing ${contract} on networks: ${networks}"
cargo run --bin install --package ${contract} --features="daemon-bin" -- --network-ids ${networks}
'''

[tasks.clean-chain]
category = "Cleanup"
condition = { fail_message = "üö´ The chain is running" }
condition_script = ["! docker ps -a | grep ${CHAIN} > /dev/null"]
description = "Clean the chain data (‚ö†Ô∏è definitively)."
script = '''
echo "Ô∏èüßπCleaning chain ${CHAIN} under ${CHAIN_HOME}"
rm -rf ${CHAIN_HOME}
'''

[tasks.chain-init-folder]
category = "Chain Management"
description = "Initialize deploy folder to make sure scripts have the right permission (needed for linux)"
script = '''
echo "Ô∏è‚ú® Create deploy folder structure"
mkdir -p ${DIR_DEPLOY}/${CHAIN}/config/keyring-test
mkdir -p ${DIR_DEPLOY}/${CHAIN}/config/gentx
mkdir -p ${DIR_DEPLOY}/${CHAIN}/keyring-test
mkdir -p ${DIR_DEPLOY}/${CHAIN}/data
'''

[tasks.chain-add-keys]
category = "Chain Management"
condition = { fail_message = "üö´ The chain is already initialized." }
condition_script = ["[ ! -f ${CHAIN_HOME}/config/genesis.json ]"]
dependencies = ["chain-init-folder"]
description = "Add a set of predefined keys (recovered from the seed phrases) to the chain."
script = '''
keys=(
  "validator:${MNEMONIC_VALIDATOR}"
  "alice:${MNEMONIC_ALICE}"
  "bob:${MNEMONIC_BOB}"
  "charlie:${MNEMONIC_CHARLIE}"
 )
for entry in "${keys[@]}" ; do
    name="${entry%%:*}"
    key="${entry##*:}"
    echo "üóùÔ∏è Adding key ${name} for chain ${CHAIN}"
    echo "${key}" \
    | docker run --rm -i \
        -v `pwd`:/app \
        -w /app \
        ${DOCKER_IMAGE_AXONEPROTOCOL_AXONED} \
          keys add ${name} \
            --recover \
            --keyring-backend ${KEYRING_BACKEND} \
            --home ${CHAIN_HOME}
done
'''

[tasks.chain-initialize]
category = "Chain Management"
condition = { fail_message = "üö´ The chain is already initialized." }
condition_script = ["[ ! -f ${CHAIN_HOME}/config/genesis.json ]"]
dependencies = ["chain-add-keys"]
description = "Initialize the chain with a validator's key and a set of predefined keys. ‚ö†Ô∏è The home directory is cleaned before."
script = '''
echo "üõ†Ô∏è Initializing chain ${CHAIN} under ${CHAIN_HOME}"
docker run --rm \
  -v `pwd`:/app \
  -w /app \
  ${DOCKER_IMAGE_AXONEPROTOCOL_AXONED} \
    init ${CHAIN_MONIKER} \
      --chain-id=${CHAIN} \
      --home ${CHAIN_HOME}

balances=(
  "validator:${BALANCE_VALIDATOR}"
  "alice:${BALANCE_ALICE}"
  "bob:${BALANCE_BOB}"
  "charlie:${BALANCE_CHARLIE}"
 )
for entry in "${balances[@]}" ; do
    name="${entry%%:*}"
    balance="${entry##*:}"
    docker run --rm -i \
      -v `pwd`:/app \
      -w /app \
      ${DOCKER_IMAGE_AXONEPROTOCOL_AXONED} \
         genesis add-genesis-account ${name} "${balance}"  \
          --keyring-backend ${KEYRING_BACKEND} \
          --home ${CHAIN_HOME}
done

NODE_ID=$(
  docker run --rm \
    -v `pwd`:/app \
    -w /app \
    ${DOCKER_IMAGE_AXONEPROTOCOL_AXONED} \
      comet show-node-id \
        --home ${CHAIN_HOME}
)
docker run --rm \
  -v `pwd`:/app \
  -w /app \
  ${DOCKER_IMAGE_AXONEPROTOCOL_AXONED} \
    genesis gentx validator 1000000uaxone \
      --node-id ${NODE_ID} \
      --chain-id=${CHAIN} \
      --keyring-backend ${KEYRING_BACKEND} \
      --home ${CHAIN_HOME}

docker run --rm \
  -v `pwd`:/app \
  -w /app \
  ${DOCKER_IMAGE_AXONEPROTOCOL_AXONED} \
	  genesis collect-gentxs \
	    --home ${CHAIN_HOME}

sed -i ${SED_FLAG} 's/"stake"/"uaxone"/g' ${CHAIN_HOME}/config/genesis.json
'''

[tasks.chain-start]
category = "Chain Management"
condition = { fail_message = "üö´ The chain is already running" }
condition_script = ["! docker ps -a | grep ${CHAIN} > /dev/null"]
description = "Run the full node axoned application using the chain's home directory under a Docker container."
script = '''
echo "üöÄ Starting chain ${CHAIN} under ${CHAIN_HOME} (using ${DOCKER_IMAGE_AXONEPROTOCOL_AXONED})"

if [ ! -f ${CHAIN_HOME}/config/genesis.json ]; then
  echo "‚ùå The chain seems to be uninitialised. Try: cargo make chain-initialize"
  exit 1
fi

sed -i ${SED_FLAG} 's|address = "localhost:9090"|address = "0.0.0.0:9090"|g' ${CHAIN_HOME}/config/app.toml
sed -i ${SED_FLAG} 's|address = "tcp://localhost:1317"|address = "tcp://0.0.0.0:1317"|g' ${CHAIN_HOME}/config/app.toml
sed -i ${SED_FLAG} 's|laddr = "tcp://127.0.0.1:26657"|laddr = "tcp://0.0.0.0:26657"|g' ${CHAIN_HOME}/config/config.toml

docker run -d \
  -p 1317:1317 -p 26657:26657 -p 9091:9090 \
  -v `pwd`:/app \
  -w /app \
  --name ${CHAIN} \
  ${DOCKER_IMAGE_AXONEPROTOCOL_AXONED} \
    start \
      --moniker ${CHAIN} \
      --home ${CHAIN_HOME}
'''

[tasks.chain-stop]
category = "Chain Management"
condition = { fail_message = "üö´ The chain is not running" }
condition_script = ["docker ps -a | grep ${CHAIN} > /dev/null"]
description = "Stop the chain's container."
script = '''
echo "üõë Stopping chain ${CHAIN} under ${CHAIN_HOME}"
docker stop ${CHAIN}
docker rm ${CHAIN}
'''

[tasks.chain-logs]
category = "Chain Management"
condition = { fail_message = "üö´ The chain is not running" }
condition_script = ["docker ps -a | grep ${CHAIN} > /dev/null"]
description = "Show the chain's container logs."
script = '''
echo "üìú Logs for chain ${CHAIN} under ${CHAIN_HOME}:"
docker logs -f ${CHAIN}
'''

[tasks.chain]
category = "Chain Management"
description = "Run the axoned CLI using the chain's home directory under a Docker container."
script = '''
echo "‚å®Ô∏è Executing ${DOCKER_IMAGE_AXONEPROTOCOL_AXONED} ${@}..."

docker run \
  --network host \
  -v `pwd`:/app \
  -w /app \
  -ti \
  --rm \
  ${DOCKER_IMAGE_AXONEPROTOCOL_AXONED} \
    ${@}
'''

[tasks.contract-list]
category = "Contract Inspection"
description = "List all the contracts deployed to the chain."
script = '''
echo "üîç Listing contracts on chain ${CHAIN}"
docker run --rm \
  --network host \
  -v `pwd`:/app:ro \
  -w /app \
  ${DOCKER_IMAGE_AXONEPROTOCOL_AXONED} \
    query wasm list-code \
      --node ${CHAIN_RPC_NODE} \
      --limit 1000 \
      --home ${CHAIN_HOME}
'''

[tasks.contract-inspect]
category = "Contract Inspection"
description = "Inspect a specific contract deployed to the chain."
script = '''
if [ -z "$1" ]
then
  echo "‚ùå Please provide the contract code ID as the first argument."
  exit 1
fi
code_id=$1
docker run --rm \
  --network host \
  -v `pwd`:/app:ro \
  -w /app \
  ${DOCKER_IMAGE_AXONEPROTOCOL_AXONED} \
    query wasm code-info $code_id \
      --node ${CHAIN_RPC_NODE} \
      --home ${CHAIN_HOME}
'''

[tasks.contract-query]
category = "Contract Interaction"
dependencies = ["chain-start"]
description = "Query a specific contract. The contract must be already deployed and instantiated."
script = '''
if [ -z "$1" ]
then
  echo "‚ùå Please provide the contract address as the first argument."
  exit 1
fi
addr=$1

if [ -z "$2" ]
then
  echo "‚ùå Please provide the contract query as the second argument."
  exit 1
fi
query=$2

echo "üì¶ Query contract ${addr} to chain ${CHAIN}"
docker run --rm \
  --network host \
  -v `pwd`:/app:ro \
  -w /app \
  ${DOCKER_IMAGE_AXONEPROTOCOL_AXONED} \
    query wasm contract-state smart ${addr} "${query}" \
      --node ${CHAIN_RPC_NODE} \
      --output json \
      | jq -r '.'
'''

[tasks.contract-execute]
category = "Contract Interaction"
dependencies = ["chain-start"]
description = "Execute a command on a specific contract. The contract must be already deployed and instantiated."
script = '''
if [ -z "$1" ]
then
  echo "‚ùå Please provide the contract address as the first argument."
  exit 1
fi
addr=$1

if [ -z "$2" ]
then
  echo "‚ùå Please provide the contract execute msg as the second argument."
  exit 1
fi
msgs=$2

echo "üì¶ Execute on contract ${addr} to chain ${CHAIN}"
docker run --rm \
  --network host \
  -v `pwd`:/app:ro \
  -w /app \
  ${DOCKER_IMAGE_AXONEPROTOCOL_AXONED} \
    tx wasm execute ${addr} "${msgs}" \
      --from validator \
      --keyring-backend test \
      --home ${CHAIN_HOME} \
      --node ${CHAIN_RPC_NODE} \
      --gas-prices 0.025uaxone \
      --gas auto \
      --gas-adjustment 1.5 \
      --chain-id ${CHAIN} \
      --yes | docker run --rm -i \
        --network host \
        -v `pwd`:/app:ro \
        -w /app \
        ${DOCKER_IMAGE_AXONEPROTOCOL_AXONED} query wait-tx \
          --node ${CHAIN_RPC_NODE} \
          --output json \
          | jq -r '.'
'''

[tasks.install-cargo-binstall]
category = "Development Tools"
description = "Install cargo-binstall if not already available"
script = '''
if command -v cargo-binstall >/dev/null 2>&1; then
    echo "‚úÖ cargo-binstall already available"
    exit 0
fi

echo "üì¶ Installing cargo-binstall..."
if curl -L --proto '=https' --tlsv1.2 -sSf https://raw.githubusercontent.com/cargo-bins/cargo-binstall/main/install-from-binstall-release.sh | bash >/dev/null; then
    if command -v cargo-binstall >/dev/null 2>&1; then
        echo "‚úÖ cargo-binstall installed successfully"
        exit 0
    fi
fi

echo "‚ùå Failed to install cargo-binstall"
exit 1
'''

[tasks.install-tool]
category = "Development Tools"
private = true
script = '''
TOOL_NAME="${CARGO_MAKE_TASK_ARGS}"
MIN_VERSION="${MIN_VERSION}"
BINARY_NAME="${BINARY_NAME:-$TOOL_NAME}"

# Check if tool is already installed and meets version requirement
if command -v "${BINARY_NAME}" >/dev/null 2>&1; then
    echo "‚úÖ ${BINARY_NAME} is already installed"
    exit 0
fi

echo "üì¶ Installing ${TOOL_NAME}..."

if command -v cargo-binstall >/dev/null 2>&1; then
    echo "‚ö° Using cargo-binstall (fast binary installation)"
    if cargo binstall "${TOOL_NAME}" --no-confirm --force; then
        echo "‚úÖ ${TOOL_NAME} installed successfully via cargo-binstall"
        exit 0
    else
        echo "‚ö†Ô∏è cargo-binstall failed, falling back to cargo install..."
    fi
fi

# Fallback to cargo install
echo "üî® Installing from source via cargo install..."
cargo install "${TOOL_NAME}" --force --locked
echo "‚úÖ ${TOOL_NAME} installed successfully"
'''

[tasks.install-cranky]
category = "Development Tools"
env = { "MIN_VERSION" = "0.3.0", "CARGO_MAKE_TASK_ARGS" = "cargo-cranky", "BINARY_NAME" = "cargo-cranky" }
run_task = "install-tool"

[tasks.install-taplo-cli]
category = "Development Tools"
env = { "MIN_VERSION" = "0.9.0", "CARGO_MAKE_TASK_ARGS" = "taplo-cli@0.9.3", "BINARY_NAME" = "taplo" }
run_task = "install-tool"

[tasks.install-cargo-toml-lint]
category = "Development Tools"
env = { "MIN_VERSION" = "0.1.1", "CARGO_MAKE_TASK_ARGS" = "cargo-toml-lint", "BINARY_NAME" = "cargo-toml-lint" }
run_task = "install-tool"

[tasks.install-llvm-cov]
category = "Development Tools"
env = { "MIN_VERSION" = "0.6.9", "CARGO_MAKE_TASK_ARGS" = "cargo-llvm-cov", "BINARY_NAME" = "cargo-llvm-cov" }
run_task = "install-tool"

[tasks.install-cosmwasm-check]
category = "Development Tools"
env = { "MIN_VERSION" = "3.0.2", "CARGO_MAKE_TASK_ARGS" = "cosmwasm-check", "BINARY_NAME" = "cosmwasm-check" }
run_task = "install-tool"

[tasks.install-cargo-workspaces]
category = "Development Tools"
env = { "MIN_VERSION" = "0.3.6", "CARGO_MAKE_TASK_ARGS" = "cargo-workspaces", "BINARY_NAME" = "cargo" }
run_task = "install-tool"

[tasks.install-cargo-hack]
category = "Development Tools"
env = { "MIN_VERSION" = "0.6.14", "CARGO_MAKE_TASK_ARGS" = "cargo-hack", "BINARY_NAME" = "cargo-hack" }
run_task = "install-tool"

[tasks.install-cargo-machete]
category = "Development Tools"
env = { "MIN_VERSION" = "0.7.0", "CARGO_MAKE_TASK_ARGS" = "cargo-machete", "BINARY_NAME" = "cargo-machete" }
run_task = "install-tool"

[tasks.install-cargo-sort-derives]
category = "Development Tools"
env = { "MIN_VERSION" = "0.10.0", "CARGO_MAKE_TASK_ARGS" = "cargo-sort-derives", "BINARY_NAME" = "cargo-sort-derives" }
run_task = "install-tool"

[tasks.install-dev-tools]
category = "Development Tools"
dependencies = [
  "install-cargo-binstall",
  "install-cranky",
  "install-taplo-cli",
  "install-cargo-toml-lint",
  "install-llvm-cov",
  "install-cosmwasm-check",
  "install-cargo-workspaces",
  "install-cargo-hack",
  "install-cargo-machete",
  "install-cargo-sort-derives",
]
description = "Install all required development tools."

[tasks.publish-crates]
args = [
  "workspaces",
  "publish",
  "--from-git",
  "--yes",
  "--no-git-commit",
  "skip",
]
category = "Publishing"
command = "cargo"
condition = { env_set = ["CARGO_REGISTRY_TOKEN"] }
dependencies = ["install-cargo-workspaces"]
description = "Publish all crates to the registry. Requires CARGO_REGISTRY_TOKEN to be set."

[tasks.readme]
category = "Documentation"
description = "Update README with help output"
script = '''
set -euo pipefail

HELP_OUTPUT="$(cargo make --silent --makefile ./Makefile.toml --list-all-steps --hide-uninteresting)"
BLOCK_FILE="$(mktemp -t readme_tasks_block.XXXXXX)"
trap 'rm -f "$BLOCK_FILE"' EXIT

{
  printf '%s\n' '<!-- TASKS -->'
  printf '%s\n' '```text'
  printf '%s\n' "${HELP_OUTPUT}"
  printf '%s\n' '```'
  printf '%s\n' '<!-- TASKS -->'
} > "${BLOCK_FILE}"

awk -v blk="${BLOCK_FILE}" '
  BEGIN{
    start="<!-- TASKS -->"; end="<!-- TASKS -->";
    replaced=0; inside=0;
    while ((getline l < blk) > 0) block = block l ORS;
    close(blk);
  }
  {
    if (!replaced && index($0, start)) {
      printf "%s", block;           # no extra ORS
      inside=1; replaced=1; next;
    }
    if (inside) {
      if (index($0, end)) { inside=0; next }
      next
    }
    print
  }
  END{
    if (!replaced) {
      printf "%s", block
    }
  }
' README.md > README.md.__new__ && mv README.md.__new__ README.md

echo "‚úÖ README.md updated"
'''
script_runner = "bash"

[config]
default_to_workspace = false
min_version = "0.36.3"
skip_core_tasks = true

[env]
CARGO_MAKE_CRATE_INSTALLATION_LOCKED = true

DOCS_FOLDER = "docs"
SCHEMA_FOLDER = "schema"

# Local chain configuration (for chain-initialize and chain management tasks)
BALANCE_ALICE = "100000000000uaxone"
BALANCE_BOB = "100000000000uaxone"
BALANCE_CHARLIE = "100000000000uaxone"
BALANCE_VALIDATOR = "1000000000uaxone"
MNEMONIC_ALICE = "code ceiling reduce repeat unfold intact cloud marriage nut remove illegal eternal pool frame mask rate buzz vintage pulp suggest loan faint snake spoon"
MNEMONIC_BOB = "add pig champion lounge initial tunnel oak panic drama float foot elegant coast manage diesel essence glory bicycle sniff upon horse crash damage bounce"
MNEMONIC_CHARLIE = "couple proud learn plunge neglect dice dry tail keen price tuition inherit ordinary portion abandon body kitten system word monitor lava quiz soup lift"
MNEMONIC_VALIDATOR = "island position immense mom cross enemy grab little deputy tray hungry detect state helmet tomorrow trap expect admit inhale present vault reveal scene atom"

# Chain runtime configuration
CHAIN = "axone-localnet"
CHAIN_HOME = "${DIR_DEPLOY}/${CHAIN}"
CHAIN_MONIKER = "local-node"
CHAIN_RPC_NODE = "tcp://127.0.0.1:26657"
DIR_DEPLOY = "${DIR_TARGET}/deploy"
DIR_TARGET = "./target"
DIR_WASM = "${DIR_TARGET}/wasm32-unknown-unknown/release"
DOCKER_IMAGE_AXONEPROTOCOL_AXONED = "axoneprotocol/axoned:13.0.0"
DOCKER_IMAGE_COSMWASM_OPTIMIZER = "cosmwasm/optimizer:0.17.0"
KEYRING_BACKEND = "test"
RUST_LOG = "info"
SED_FLAG = { script = [
  '''if [ ${SHELL_NAME} = 'Darwin' ]; then echo "\'\'"; else echo; fi''',
] }
SHELL_NAME = { script = ["uname -s"] }
